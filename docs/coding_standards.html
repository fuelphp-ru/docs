<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" href="./../assets/css/combined.css">
	<script src="http://www.google.com/jsapi" type="text/javascript"></script>
	<script type="text/javascript">
		var path = './../';
	</script>
	<script src="./../assets/js/combined.js"></script>
	<title>Стандарты программирования - Общее - Документация FuelPHP</title>
</head>
<body>
	<div id="container">
		<header id="header">
			<div class="table">
				<h1>
					<strong>FuelPHP, среда разработки PHP 5.3</strong>
					Документация
				</h1>

				<form id="google_search">
					<p>
						<span>Нужна помощь с переводом. Skype: SunwayOS</span><br>
						<span>Группа вконтакте: <a href="http://vk.com/fuelphp">FuelPHP</a></span>
                        <span>Форум: <a href="http://forum.fuelphp-framework.ru">Forum.fuelphp-framework.ru</a></span>
					</p>
				</form>
			</div>
			<nav>

				<div class="clear"></div>
			</nav>
			<a href="#" id="toc_handle">содержание</a>
			<div class="clear"></div>
		</header>

		<div id="cse">
			<div id="cse_point"></div>
			<div id="cse_content"></div>
		</div>

		<div id="main">

			<h2>Стандарты программирования</h2>

			<p>Данные стандарты оформления кода и документирования должны соблюдать все, кто вносит вклад в Fuel. AЛюбой вклад. не соответствующий данным нормам, будет отвергнут.</p>

			<h3 id="file_formatting">Форматирование файла</h3>

			<h5 id="closing_php_tag">Закрывающий тег PHP</h5>

			<p>В файлах, содержащих только код PHP, всегда должен опускаться закрывающий тег PHP (?>). Это предотвращает многие трудные для понимания белые экраны смерти.</p>

			<h5 id="indentation">Отступы</h5>

			<p>Все отступы должны делаться с помощью реальной табуляции, а не пробелов.<br />
				Но выравнивание команд после отступов должно выполняться с помощью пробелов, а не табуляции.</p>

			<pre class="php"><code>		// сделан отступ в 2 табуляции
		$var       = 'something';  // сделан отступ с помощью табуляций, а значение и комментарии выровнены
		$variable  = 'else';       // с помощью пробелов с теми, которые расположены выше/ниже</code></pre>

			<h5 id="line_endings">Концы строк</h5>

			<p>Концом строки должен быть символ "перевод строки" в стиле Unix.</p>

			<h5 id="file_naming">Именование файлов</h5>

			<p>Все имена файлов должны быть полностью в нижнем регистре. Исключений нет.</p>

			<h5 id="encoding">Кодировка</h5>

			<p>Файлы должны быть сохранены с использованием кодировки UTF-8, BOM(отметка порядка байтов) нельзя использовать.</p>

			<h3 id="naming_conventions">Соглашения об именовании</h3>

			<h5 id="namespaces">Пространства имен</h5>

			<p>Все классы ядра должны принадлежать пространству имен Fuel\Core.</p>

			<pre class="php"><code>namespace Fuel\Core;</code></pre>

			<h5 id="classes">Классы</h5>

			<p>Имена классов должны использовать символы подчеркивания для разделения слов, и каждое слово в имени класса должно начинаться с
				большой буквы. Однако символ подчеркивания будет преобразован в разделитель каталогов во время автозагрузки. Использование горбатого регистра не одобряется, но без него не обйтись в ряде случаев, когда помещать класс в подкаталог не имеет смысла.</p>

			<pre class="php"><code>namespace Fuel\Core;

class Session
{

}</code></pre>

			<pre class="php"><code>namespace Fuel\Core;

class Session_Cookie extends Session_Driver
{

}</code></pre>

			<p>Данные классы дадут следующие пути к файлам:</p>

			<pre class="php"><code>core/classes/session.php
core/classes/session/cookie.php</code></pre>

			<h5 id="methods">Методы</h5>

			<p>Как и имена классов, имена методов должны использовать символы подчеркивания для разделения слов, а не горбатый регистр. Имена методов также должны быть полностью в нижнем регистре. Видимость всегда должна быть включена (открытый, защищенный, закрытый).<br />
				В начале имени может использоваться символ подчеркивания, чтобы показать, что метод защищенный/закрытый, или
				чтобы указать, что он должен рассматриваться как таковой, когда он нужен вам открытым.</p>

			<pre class="php"><code>class Session
{

	public static function get_flash($name, $data)
	{
		// Здесь должен быть какой-нибудь код
	}

}</code></pre>

			<pre class="php"><code>class View
{

	// Массив глобальных данных представления
	protected static $_global_data = array();

	protected static function capture($view_filename, array $view_data)
	{
		// Здесь должен быть какой-нибудь код
	}

}</code></pre>

			<h5 id="variables">Переменные</h5>

			<p>Имена переменных должны быть краткими и должны содержать только буквы нижнего регистра и символы подчеркивания. Итераторы циклов должны быть
				короткими, желательно из одного символа.</p>

			<pre class="php"><code>$first_name
$buffer
for ($i = 0; $i &lt; $max; $i++)</code></pre>

			<h5 id="constants">Константы</h5>

			<p>Константы соблюдают те же правила, что и переменные, за исключением того, что константы должны записываться полностью
				в верхнем регистре.</p>

			<pre class="php"><code>MY_CONSTANT
TEMPLATE_PATH
TEXT_DEFAULT</code></pre>

			<h3 id="keywords">Ключевые слова</h3>

			<p>Ключевые слова, такие как <kbd>true(истина)</kbd>, <kbd>false(ложь)</kbd>, <kbd>null(ноль)</kbd>, <kbd>as(как, в качестве)</kbd>, и т.д. должны быть полностью в нижнем регистре, так как верхний регистр зарезервирован для
				констант. То же самое принято для простых типов, таких как <kbd>array(массив)</kbd>, <kbd>integer(целое число)</kbd>, <kbd>string(строка)</kbd>.</p>

			<pre class="php"><code>$var = true;
$var = false;
$var = null;
foreach ($array as $key => $value)
public function my_function(array $array)
function my_function($arg = null)</code></pre>

			<h3 id="control_structures">Управляющие конструкции</h3>

			<p>Ключевые слова конструкций, такие как <kbd>if</kbd>, <kbd>for</kbd>, <kbd>foreach</kbd>, <kbd>while</kbd>, <kbd>switch</kbd> должны сопровождаться пробелом, как должны и
				списки параметров/агрументов и значения. Фигурные скобки должны располагаться на новой строке, и оператор <kbd>break</kbd> должен иметь такую же
				табуляцию, как и его ключевое слово case(вариант).</p>

			<pre class="php"><code>if ($arg === true)
{
	//здесь что-то делается
}
elseif ($arg === null)
{
	//здесь делается что-то другое
}
else
{
	//захватываются все значения и что-то делается
}
foreach ($array as $key => $value)
{
	//здесь тело цикла
}
for ($i = 0; $i < $max; $i++)
{
	//здесь тело цикла
}
while ($i < $max)
{
	//здесь тело цикла
}
switch ($var)
{
	case 'value1':
		//здесь что-то делается
	break;
	default :
		//здесь что-то делается
	break;
}</code></pre>

			<h5 id="alternative_if">Альтернативные условные операторы if</h5>

			<p>В ряде случаев полный оператор <kbd>if</kbd> - это слишком много кода для простого условного присваивания или вызова
				функции. В таких случаях вы можете воспользоваться логикой выполнения PHP, чтобы использовать более краткий синтаксис на базе логических операторов.
				Использование <kbd>and(и)</kbd> означает, что вторая часть вычисляется, только если первая часть была истинной. Использование
				<kbd>or(или)</kbd> означает, что вторая часть выполняется, только если первая часть была ложной.<br />
				Не используйте их, когда нужны и <kbd>if</kbd>, и <kbd>else</kbd>, применяйте их только если нужен одиночный условный оператор.</p>

			<pre class="php"><code>// вместо if (isset($var)) { Config::set('var', $var); }
isset($var) and Config::set('var', $var);

// вместо if ( ! isset($var)) { $var = Config::get('var'); }
isset($var) or $var = Config::get('var');

// не делайте так
Uri::segment(3) and $var = Uri::segment(3);
Uri::segment(3) or $var = 'default';

// Так лучше:
if (Uri::segment(3))
{
	$var = Uri::segment(3);
}
else
{
	$var = 'default';
}

// Или так:
$var = Uri::segment(3) ? Uri::segment(3) : 'default';
// Или даже так:
$var = Uri::segment(3) ?: 'default';</code></pre>

			<h3 id="comparison_logical">Сравнения, логические операторы</h3>

			<p>Возвращаемые значения и переменные функций/методов сравнения должны учитывать тип, например, некоторые функции могут возвращать
				<kbd>false</kbd>, и при сравнении данного возвращаемого значения должны применяться чувствительные к типу операторы, такие как <kbd>===</kbd> или <kbd>!==</kbd>. Кроме того, использование
				<kbd>and</kbd> или <kbd>or</kbd> предпочтительней, чем <kbd>&&</kbd> или <kbd>||</kbd>, с позиции читабельности. В ряде случаев, этого нельзя избежать, и при необходимости можно использовать <kbd>&&</kbd> или <kbd>||</kbd>. При использовании <kbd>!</kbd> нужно ставить пробелы с обеих его сторон.</p>

			<pre class="php"><code>if ($var == false and $other_var != 'some_value')
if ($var === false or my_function() !== false)
if ( ! $var)</code></pre>

			<h5 id="class_interface">Объявления класса/интерфейса</h5>

			<p>Объявления класса/интерфейса имеют открывающую фигурную скобку в следующей строке:</p>

			<pre class="php"><code>class Session
{

}</code></pre>

			<h5 id="function_method">Объявления функции/метода</h5>

			<p>Открывающая фигурная скобка функции/метода всегда должна начинаться с новой строки и и иметь такой же отступ, каки у ее конструкции.</p>

			<pre class="php"><code>class Session
{

	public static function get_flash($name, $data)
	{
		// здесь должен быть какой-то код
	}

}</code></pre>

			<h5 id="variables">Переменные</h5>

			<p>При инициализации переменных должно объявляться одна переменная на каждой строке. Чтобы улучшить читабельность кода, переменная должна объявляться на отдельной строке. Когда это целесообразно, выравнивайте значения и комментарии.</p>

			<pre class="php"><code>$var        = ''; // каждая переменная объявляется на отдельной строке
$other_var  = ''; // каждая переменная объявляется на отдельной строке</code></pre>

			<h5 id="brackets_parenthesis">Квадратные скобки и круглые скобки</h5>

			<p>Перед или после открывающей квадратной или круглой скобки не должно быть никаких пробелов. Не должно быть пробела перед закрывающей квадратной или круглой скобкой.</p>

			<pre class="php"><code>$array = array(1, 2, 3, 4);
$array['my_index'] = 'something';
for ($i = 0; $i < $max; $i++)</code></pre>

			<h5 id="quotation">Заключение строк в кавычки</h5>

			<p>Одинарные кавычки предпочтительней, чем двойные кавычки.</p>

			<h5 id="concatenation">Конкатенация</h5>

			<p>Конкатенация строк не не должна содержать пробелы около соединяемых частей.</p>

			<pre class="php"><code>//да
$string = 'my string '.$var.' the rest of my string';

//нет
$string = 'my string ' . $var . ' the rest of my string';</code></pre>

			<h5 id="operators">Операторы</h5>

			<pre class="php"><code>$var = 'something';
if ($var == 'something') //пробел до и после логического оператора
$var = $some_var + $other_var; //пробел до и после арифметического оператора
$var++; // перед инкрементом нет пробела
++$var; //после инкремента нет пробела</code></pre>

		</div>

		<footer>
			<p>
				&copy; Группа разработчиков FuelPHP 2010-2011 - <a href="http://fuelphp.com">FuelPHP</a> выпущен по лицензии MIT.
			</p>
		</footer>
	</div>
</body>
</html>
