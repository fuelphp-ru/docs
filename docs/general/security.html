<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8">	
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" href="./../assets/css/combined.css">
	<script src="http://www.google.com/jsapi" type="text/javascript"></script>
	<script type="text/javascript">
		var path = './../';
	</script>
	<script src="./../assets/js/combined.js"></script>
	<title>Security - General - FuelPHP Documentation</title>
</head>
<body>
	<div id="container">
		<header id="header">
			<div class="table">
				<h1>
					<strong>FuelPHP, a PHP 5.3 Framework</strong>
					Документация
				</h1>
				
				<form id="google_search">
					<p>
						<span>Нужна помощь с переводом. Skype: SunwayOS</span><br>
						<span>Группа вконтакте: <a href="http://vk.com/fuelphp">FuelPHP</a></span>
					</p>
				</form>
			</div>
			<nav>
				
				<div class="clear"></div>
			</nav>
			<a href="#" id="toc_handle">содержание</a>
			<div class="clear"></div>
		</header>
		
		<div id="cse">
			<div id="cse_point"></div>
			<div id="cse_content"></div>
		</div>
		
		<div id="main">
		
			<h2>Защита</h2>
	
			<p>
				Fuel очень серьезно относится к защите, и в итоге реализовал следующие меры для обеспечения безопасности ваших веб-приложений:
			</p>
	
			<ul>
				<li><a href="#output">Кодирование вывода</a></li>
				<li><a href="#csrf">Защита CSRF</a></li>
				<li><a href="#xss">Фильтрация XSS</a></li>
				<li><a href="#input">Фильтрация входных данных</a></li>
				<li><a href="#sql">Инъекция SQL</a></li>
			</ul>
			<p>
				По умолчанию Fuel не фильтрует переменные POST и GET на входе, а кодирует все на выходе.
				Fuel также кодирует URI, чтобы предотвратить неприятные сюрпризы при использовании сегментов URI, и экранирует все, поступающее в базу даных.
			</p>
			<p>
				Данная страница объясняет основные способы защиты, предлагаемые Fuel, класс защиты документирован в классах. На той странице также изложены подробные данные по конфигурированию класса защиты Fuel.
			</p>
	
			<article id="output">
				<h3>Кодирование вывода</h3>
	
				<p>
					По умолчанию Fuel предпочитает кодирование вывода, а не фильтрацию входных данных. Причина в том, что она двойная.
					Независимо от того, откуда ваши данные происходят, и отфильтрованы они или нет, кодирование вывода сделает их безопасными,
					когда они отправляются клиенту. Это также означает, что все входные данные сохраняются в необработанной и неизмененной форме, чтобы в любом случае у вас был доступ к исходным данным.
				</p>
				<p>
					Это также значит, что вы не столкнетесь с проблемами, когда вам понадобятся данные в неизмененной форме. Один типичный пример -
					данные, порожденные редакторами html, такими как TinyMCE или ckeditor, используемые во многих приложениях для редактирования содержимого конечного пользователя.
					В таких случаях вам может понадобиться выполнить фильтрацию <a href="#xss">XSS Filtering</a> над этими входными переменными, чтобы отфильтровать любые неприятные сюрпризы, которые могли закрасться, так как это типичный пример данных, которые неудобно кодировать на выходе.
				</p>
				<p>
					Так как кодирование вывода может выполняться только над строками, вы должны обращать внимание на объекты, которые вы хотите передавать вашим представлениям.
					Убедитесь, что ваш объект содержит метод <strong>__toString(),</strong> способный выполнять кодирование, добавьте класс вашего объекта
					белый список классов в конфигурации защиты (не забудьте пространства имен!), или передайте его представлению с флагом <strong>$encode</strong>,
					установленным в ложь.
					Вы также можете воспользоваться методом <a href="../classes/view.html#method_auto_encode">auto_encode</a> для временного отключения автоматического кодирования вывода
					для каждого отдельного представления.
				</p>
				<p>
					Рассмотрение реализации указанной возможности для предсталвений дано в разделе <a href="views.html#security">защита представления</a>.
				</p>
			</article>
	
			<article id="csrf">
			  <h3>Защита CSRF</h3>
				<p>
					Межсайтовая подделка запроса, также именуемая атакой за один щелчок мышью или захват сессии, сокращенно называемая CSRF, - тип вредоносной атаки на вебсайт, при которой запрещенные команды передаются от пользователя, которому вебсайт доверяет. В отличие от межсайтового скриптинга (XSS),
					эксплуатирующего доверие, оказываемое пользователем конкретному сайту, CSRF эксплуатирует доверие, оказываемое сайтом браузеру пользователя.
					Атака выполняется путем включения ссылки или скрипта в страницу, подключающуюся к сайту, на котором пользователь точно (или предположительно) был опознан.
				</p>
				<p>
					Например, один пользователь, Боб, может просматривать чат, где другой пользователь, Мэллори, опубликовал сообщение.
					Предположим, что Мэллори создал элемент изображения HTML, ссылающийся на действие на вебсайте банка Боба (rвместо примера файла изображения).
					Если банк Боба хранит его аутентификационную информацию в куки-файле, и если срок действия куки-файла не истек, то попытка загрузить изображение через браузер Боба передаст форму снятия денег со счета с помощью его куки-файла, тем самым разрешив транзакцию без подтверждения Боба.
					<span style="float:right;font-style:italic;"><a href="http://en.wikipedia.org/wiki/Cross-site_request_forgery">источник: wikipedia</a></span>
				</p>
				<p>
					Fuel предоставляет вам инструменты для защиты ваших форм от данного вида атак, путем включения маркера доступа в форму, правильность которого можно проверить после передачи формы, и подтверждение его правильности гарантирует, что форма была передана клиентом, запросившим форму.
				</p>
				<p>
					Защита от CSRF может быть настроена через раздел защиты в файле config/config.php приложения.
				</p>
	
	
				<p>Чтобы активировать защиту от CRSF, начните с добавления маркера в вашу форму:</p>
				<pre class="php"><code>// на простом HTML
&lt;input type="hidden" name="&lt;?php echo \Config::get('security.csrf_token_key');?&gt;" value="&lt;?php echo \Security::fetch_token();?&gt;" /&gt;

// использование класса Форма
echo \Form::hidden(\Config::get('security.csrf_token_key'), \Security::fetch_token());

// использование экземпляра формы, добавляется правило проверки для набора полей формы
$form = \Form::forge();
$form->add_csrf();
</code></pre>
			<p>Чтобы вручную проверить, была ли форма передана клиентом, запросившим форму:</p>
		<pre class="php"><code>// проверяем, была ли форма передан
if ($_POST)
{
	// проверяем правильность маркера CSRF
	if ( ! \Security::check_token())
	{
		// атака CSRF или недействительный маркер CSRF
	}
	else
	{
		// маркер правильный, можно обрабатывать входные данные формы
	}
}
</code></pre>
	
			</article>
	
			<article id="xss">
			  <h3>Фильтрация XSS</h3>
				<p>
					Fuel обеспечивает фильтрацию XSS с помощью библиотеки <a href="http://www.bioinformatics.org/phplabware/internal_utilities/htmLawed/">HTMLawed</a>,
					очень быстрой и крайне гибкой библиотеки. По умолчанию она работает в безопасном и сбалансированном режиме.
				</p>
				<p>
					Безопасный относится к HTML, ограниченном для уменьшения уязвимости к атакам скриптинга (таким как XSS), основанным на коде HTML, который в иных случаях может быть разрешенным и соответствующим требованиям стандарта HTML. Когда элементы, такие как скрипт и объект, и атрибуты,
					такие как onmouseover(при наведении курсора) и style(стиль), разрешены во вводимом тексте, автор ввода можт ввести зловредный код HTML.
				</p>
				<p>
					В сбалансированном режиме HTMLawed проверяет и исправляет входные данные, чтобы получить правильно сбалансированные теги и разрешенное содержимое элемента
					(т.е., любое вложение элемента должно быть правильным, и неформатированный текст может присутствовать только в содержимом элементов, допускающих его).
				</p>
				<p class="note">
					По причине производительности рекомендуется использовать метод <a href="../classes/security.html#method_xss_clean">xss_clean</a> для отдельных входных значений, а не как общий фильтр входных данных.
				</p>
			</article>
	
			<article id="input">
				<h3>Фильтрация входных данных</h3>
				<p>
					Хотя она не автивирована по умолчанию, можно настроить Fuel на фильтрацию всех входных данных ($_GET, $_POST и $_COOKIE) в каждом запросе страницы.
					Для этого настройте функции или методы, используемые для фильтрации ввода, в файле config/config.php приложений.
				</p>
				<pre class="php"><code>/**
 * Параметры защиты
 */
'security' => array(
    'input_filter' => array(),
)</code></pre>
				<p>
					Все, что может быть вызвано в PHP и принимает отдельное значение в качестве параметра, может применяться для фильтрации.
					Сюда входят функции PHP, такие как 'htmlentities', статические методы классов, такие как '\\Security::xss_clean', или даже методы объектов,
					определенные в виде <strong>array($object, 'method')</strong>. Если вы используете метод объекта, убедитесь, что объект доступен перед инициализацией Fuel, так как фильтрация входных данных выполняется в самом начале обработки запроса.
				</p>
			</article>
	
			<article id="sql">
				<h3>SQL инъекция</h3>
				<p>
					SQL инъекция - метод внедрения кода, эксплуатирующий уязвимость защиты, возникающую на уровне баз данных приложения
					(например, запросы). Уязвимость существует, когда введенные пользователем данные неправильно очищаются от строковых буквенных символов начала управляющей последовательности,
					внедренных в операторы SQL, или ввод пользователя не строго типизирован и в силу этого неожиданно выполняется.
					Это пример более общего класса уязвимостей, которые могут появляться всякий раз, когда один язык программирования или скриптов внедряется внутрь другого. Атаки инъекции SQL также называются атаками ввода SQL.
					<br />
					Такая форма инъекции SQL происходит, когда ввод пользователя не очищается от управляющих символов и затем передается в оператор SQL.
					Это приводит к потенциальной подделке операторов, выполняемые над базой данных конечным пользователем приложения.
					<span style="float:right;font-style:italic;"><a href="http://en.wikipedia.org/wiki/SQL_injection">источник: wikipedia</a></span>
				</p>
				<p>
					Fuel защищает от инъекции SQL путем экранирования всех значений, передаваемых одному из методов класса базы данных. Так как это выполняется на уровне центрального конструктора запросов Fuel, весь код, использующий конструктор запросов, включая пакет Fuel ORM, будет автоматически использовать экранирование.
				</p>
	
			</article>

		</div>

		<footer>
			<p>
				&copy; FuelPHP Development Team 2010-2011 - <a href="http://fuelphp.com">FuelPHP</a> is released under the MIT license.
			</p>
		</footer>
	</div>
</body>
</html>